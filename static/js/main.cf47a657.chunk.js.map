{"version":3,"sources":["interfaces/enum.ts","store/hooks.ts","store/features/theme/themeSlice.ts","components/App/App.tsx","store/features/externalCmd/externalCmd.ts","store/features/file/fileSlice.ts","store/features/proof/auxi.ts","store/features/theme/auxi.ts","store/features/proof/proofSlice.ts","store/store.ts","ReactUtils/reportWebVitals.ts","index.tsx"],"names":["drawerHelpersKind","renderLetKind","ClusterKind","useAppSelector","useSelector","themeSlice","createSlice","name","initialState","value","reducers","toggle","state","selectTheme","actions","theme","App","useState","useReducer","isOpen","drawerIsOpen","smtDrawerIsOpen","darkTheme","useEffect","document","getElementsByClassName","className","style","height","externalCmd","findData","nodeToFind","findOption","renderData","count","fileChanged","findNode","action","payload","nodeId","option","reRender","addRenderCount","blockRender","allowRenderNewFile","blockRenderNewFile","fileSlice","filesCount","set","removeEscapedCharacters","s","newS","i","length","descendants","proof","children","concat","reduce","acc","childId","sliceNodesCluster","clusterMap","slicedClusters","currentNode","id","parentsClusters","parents","p","clusterType","keys","Object","target","Number","push","clusterID","forEach","c","child","extractTheoryLemmas","clusters","haveCluster","conclusion","filter","type","TL","map","hiddenNodes","n","rule","colorConverter","colorName","color","proofSlice","view","letMap","theoryLemmaMap","visualInfo","clustersInfos","smt","process","proofJSON","dot","isJSON","indexOf","JSON","parse","nodes","args","NaN","dependencies","NONE","comment","slice","lastIndexOf","replace","split","line","search","label","idx","thisType","numbers","substring","str","num","SAT","CNF","PP","IN","parseInt","trim","attributes","commentJSON","subProofQty","x","parent","isNaN","processDot","clustersColors","clustersMap","Array","fill","cluster","node","y","selected","size","hideNodes","toHideNodes","every","hiddenNodesArray","clusteredNodes","hiddenNode","hiddenID","some","_p","pastCluster","stringify","clusterParents","parentCluster","splice","findNodesClusters","piNodeId","foldAllDescendants","index","self","unhideNodes","pi","hiddens","setVisualInfo","selectNodes","len","unselectNodes","changeStyle","applyView","visualInfoSize","proofSize","applyColor","setSmt","store","configureStore","reducer","file","fileReducer","proofReducer","themeReducer","externalCmdReducer","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.cf47a657.chunk.js","sourcesContent":["export enum drawerHelpersKind {\r\n    RULE,\r\n    ARGS,\r\n    CONC,\r\n    ALL,\r\n}\r\n\r\nexport enum renderLetKind {\r\n    EXPAND,\r\n    REVERT,\r\n}\r\n\r\nexport enum ClusterKind {\r\n    NONE,\r\n    SAT,\r\n    CNF,\r\n    TL,\r\n    PP,\r\n    IN,\r\n}\r\n","import { TypedUseSelectorHook, useDispatch, useSelector } from 'react-redux';\r\nimport type { RootState, AppDispatch } from './store';\r\n\r\n// Use throughout your app instead of plain `useDispatch` and `useSelector`\r\nexport const useAppDispatch = () => useDispatch<AppDispatch>();\r\nexport const useAppSelector: TypedUseSelectorHook<RootState> = useSelector;\r\n","import { createSlice } from '@reduxjs/toolkit';\r\nimport { RootState } from '../../store';\r\nimport { ThemeState } from '../../../interfaces/interfaces';\r\n\r\nconst initialState: ThemeState = {\r\n    value: true,\r\n};\r\n\r\nexport const themeSlice = createSlice({\r\n    name: 'theme',\r\n    initialState,\r\n    // The `reducers` field lets us define reducers and generate associated actions\r\n    reducers: {\r\n        toggle: (state) => {\r\n            state.value = !state.value;\r\n        },\r\n    },\r\n});\r\n\r\nexport const { toggle } = themeSlice.actions;\r\n\r\n// The function below is called a selector and allows us to select a value from\r\n// the state. Selectors can also be defined inline where they're used instead of\r\n// in the slice theme. For example: `useSelector((state: RootState) => state.counter.value)`\r\nexport const selectTheme = (state: RootState): boolean => state.theme.value;\r\n\r\nexport default themeSlice.reducer;\r\n","import React, { useEffect, useReducer, useState } from 'react';\r\n\r\nimport { Intent, Position, Toaster } from '@blueprintjs/core';\r\n\r\nimport VisualizerNavbar from '../VisualizerNavbar/VisualizerNavbar';\r\nimport VisualizerDialog from '../VisualizerDialog/VisualizerDialog';\r\nimport VisualizerStage from '../VisualizerStage/VisualizerStage';\r\nimport VisualizersDrawer from '../VisualizersDrawer/VisualizersDrawer';\r\n\r\nimport { useAppSelector } from '../../store/hooks';\r\nimport { selectTheme } from '../../store/features/theme/themeSlice';\r\nimport VisualizerTutorial from '../VisualizerTutorial/VisualizerTutorial';\r\nimport VisualizerSmtDrawer from '../VisualizerSmtDrawer/VisualizerSmtDrawer';\r\n\r\nconst App: React.FC = () => {\r\n    const [dialogIsOpen, setDialogIsOpen] = useState(true);\r\n    const [inTutorial, setInTutorial] = useState(false);\r\n    const [drawerIsOpen, setDrawerOpenState] = useReducer((isOpen) => !isOpen, false);\r\n    const [smtDrawerIsOpen, setSmtDrawerIsOpen] = useReducer((isOpen) => !isOpen, false);\r\n    const darkTheme = useAppSelector(selectTheme);\r\n\r\n    // Toaster\r\n    let toaster: Toaster;\r\n    const refHandlers = {\r\n        toaster: (ref: Toaster) => (toaster = ref),\r\n    };\r\n\r\n    const addErrorToast = (err: string) => {\r\n        toaster.show({ icon: 'warning-sign', intent: Intent.DANGER, message: err });\r\n    };\r\n\r\n    useEffect(() => {\r\n        document.getElementsByClassName('bp3-overlay')[0]\r\n            ? (document.getElementsByClassName('bp3-overlay')[0].className = '')\r\n            : null;\r\n    }, [drawerIsOpen]);\r\n\r\n    return (\r\n        <div className={darkTheme ? ' bp3-dark' : ''} style={{ height: '100%' }}>\r\n            {/* <VisualizerTutorial inTutorial={inTutorial} setInTutorial={setInTutorial} /> */}\r\n            {/* <Toaster position={Position.TOP} ref={refHandlers.toaster} /> */}\r\n            {/* <VisualizerNavbar\r\n                setDialogIsOpen={setDialogIsOpen}\r\n                setDrawerIsOpen={setDrawerOpenState}\r\n                addErrorToast={addErrorToast}\r\n                inTutorial={inTutorial}\r\n                setInTutorial={setInTutorial}\r\n                setSmtDrawerIsOpen={setSmtDrawerIsOpen}\r\n            /> */}\r\n            {/* <VisualizerDialog\r\n                dialogIsOpen={dialogIsOpen}\r\n                setDialogIsOpen={setDialogIsOpen}\r\n                addErrorToast={addErrorToast}\r\n            /> */}\r\n            {/* <VisualizerStage /> */}\r\n            {drawerIsOpen ? (\r\n                <h1>visualizer drawers</h1>\r\n            ) : // <VisualizersDrawer drawerIsOpen={drawerIsOpen} setDrawerIsOpen={setDrawerOpenState}></VisualizersDrawer>\r\n            null}\r\n            {smtDrawerIsOpen ? (\r\n                // <VisualizerSmtDrawer isOpen={smtDrawerIsOpen} setDrawerIsOpen={setSmtDrawerIsOpen} />\r\n                <h1>smt drawer</h1>\r\n            ) : null}\r\n            <h1>testeee</h1>\r\n        </div>\r\n    );\r\n};\r\n\r\nexport default App;\r\n","import { createSlice, PayloadAction } from '@reduxjs/toolkit';\r\nimport { RootState } from '../../store';\r\nimport { ExternalCmdState } from '../../../interfaces/interfaces';\r\n\r\nconst initialState: ExternalCmdState = {\r\n    findData: {\r\n        nodeToFind: -1,\r\n        findOption: false,\r\n    },\r\n    renderData: {\r\n        count: 0,\r\n        fileChanged: false,\r\n    },\r\n};\r\n\r\nexport const externalCmd = createSlice({\r\n    name: 'externalCmd',\r\n    initialState,\r\n    reducers: {\r\n        findNode: (state, action: PayloadAction<{ nodeId: number; option: boolean }>) => {\r\n            state.findData = { nodeToFind: action.payload.nodeId, findOption: action.payload.option };\r\n        },\r\n        reRender: (state) => {\r\n            state.renderData.count = 0;\r\n        },\r\n        addRenderCount: (state) => {\r\n            state.renderData.count++;\r\n        },\r\n        blockRender: (state) => {\r\n            state.renderData.count = 2;\r\n        },\r\n        allowRenderNewFile: (state) => {\r\n            state.renderData.fileChanged = true;\r\n        },\r\n        blockRenderNewFile: (state) => {\r\n            state.renderData.fileChanged = false;\r\n        },\r\n    },\r\n});\r\n\r\nexport const { findNode, reRender, addRenderCount, blockRender, allowRenderNewFile, blockRenderNewFile } =\r\n    externalCmd.actions;\r\n\r\nexport const selectFindData = (state: RootState): { nodeToFind: number; findOption: boolean } =>\r\n    state.externalCmd.findData;\r\n\r\nexport const selectRenderData = (state: RootState): { count: number; fileChanged: boolean } =>\r\n    state.externalCmd.renderData;\r\n\r\nexport default externalCmd.reducer;\r\n","import { createSlice, PayloadAction } from '@reduxjs/toolkit';\r\nimport { RootState } from '../../store';\r\nimport { FileState } from '../../../interfaces/interfaces';\r\n\r\nconst initialState: FileState = {\r\n    name: 'ex.smt2',\r\n    value: 'digraph proof {\\n\\trankdir=\"BT\";\\n\\tnode [shape=record];\\n\\t0 [label=\"{SCOPE((not a), a)|(not (and (not a) a))}\", class = \" basic \", comment = \"{\\'subProofQty\\':1}\" ];\\n\\t1 [label=\"{CHAIN_RESOLUTION(true, a)|false}\", class = \" propositional \", comment = \"{\\'subProofQty\\':2}\" ];\\n\\t2 [label=\"{ASSUME(a)|a}\", comment = \"{\\'subProofQty\\':0}\"];\\n\\t3 [label=\"{ASSUME((not a))|(not a)}\", comment = \"{\\'subProofQty\\':0}\"];\\n\\t1->0;\\n\\t2->1;\\n\\t3->1;\\n}',\r\n    filesCount: 0,\r\n};\r\n\r\nexport const fileSlice = createSlice({\r\n    name: 'file',\r\n    initialState,\r\n    // The `reducers` field lets us define reducers and generate associated actions\r\n    reducers: {\r\n        set: (state, action: PayloadAction<{ name: string; value: string }>) => {\r\n            state.name = action.payload.name;\r\n            if (state.value !== action.payload.value) {\r\n                state.value = action.payload.value;\r\n                state.filesCount++;\r\n            }\r\n        },\r\n    },\r\n});\r\n\r\nexport const { set } = fileSlice.actions;\r\n\r\n// The function below is called a selector and allows us to select a value from\r\n// the state. Selectors can also be defined inline where they're used instead of\r\n// in the slice file. For example: `useSelector((state: RootState) => state.counter.value)`\r\nexport const selectFileName = (state: RootState): string => state.file.name;\r\n\r\nexport const selectFileExtension = (state: RootState): string => {\r\n    const ext = state.file.name.split('.').pop();\r\n    return ext ? ext : '';\r\n};\r\n\r\nexport const selectDot = (state: RootState): string =>\r\n    state.file.name.split('.').pop() === 'json' ? JSON.parse(state.file.value).dot : state.file.value;\r\n\r\nexport const selectFile = (state: RootState): string => state.file.value;\r\n\r\nexport const selectFileCount = (state: RootState): number => state.file.filesCount;\r\n\r\nexport default fileSlice.reducer;\r\n","import { ClusterKind } from '../../../interfaces/enum';\r\nimport { NodeInterface, ProofState } from '../../../interfaces/interfaces';\r\n\r\ninterface ClusterColorMap {\r\n    [type: number]: string;\r\n}\r\n\r\nfunction removeEscapedCharacters(s: string): string {\r\n    let newS = '';\r\n    for (let i = 0; i < s.length; i += 1) {\r\n        if (\r\n            !(\r\n                s[i] === '\\\\' &&\r\n                (s[i + 1] === '\"' ||\r\n                    s[i + 1] === '>' ||\r\n                    s[i + 1] === '<' ||\r\n                    s[i + 1] === '{' ||\r\n                    s[i + 1] === '}' ||\r\n                    s[i + 1] === '|')\r\n            )\r\n        ) {\r\n            newS += s[i];\r\n        }\r\n    }\r\n\r\n    return newS;\r\n}\r\n\r\nexport function processDot(dot: string): [NodeInterface[], ProofState['letMap'], ClusterColorMap] {\r\n    const nodes: NodeInterface[] = [\r\n        {\r\n            id: 0,\r\n            conclusion: '',\r\n            rule: '',\r\n            args: '',\r\n            children: [],\r\n            parents: [NaN],\r\n            descendants: 0,\r\n            dependencies: [],\r\n            clusterType: ClusterKind.NONE,\r\n        },\r\n    ];\r\n    let comment: string | null = dot.slice(dot.indexOf('comment='));\r\n    comment = comment\r\n        ? removeEscapedCharacters(\r\n              removeEscapedCharacters(comment.slice(comment.indexOf('=') + 2, comment.indexOf(';') - 1)),\r\n          )\r\n        : null;\r\n\r\n    const clustersInfos: ClusterColorMap = {};\r\n    const lines = dot\r\n        .slice(dot.indexOf('{') + 1, dot.lastIndexOf('}') - 2)\r\n        .replace(/(\\n|\\t)/gm, '')\r\n        .split(';');\r\n    lines.forEach((line) => {\r\n        if (line.search('subgraph') !== -1) {\r\n            // Get the label of this node subgraph\r\n            let label = '';\r\n            let idx = line.indexOf('label=\"') + 7;\r\n            while (line[idx] !== '\"') {\r\n                label += line[idx];\r\n                idx++;\r\n            }\r\n\r\n            // Get the label of this node subgraph\r\n            let color = '';\r\n            idx = line.indexOf('bgcolor=\"') + 9;\r\n            while (line[idx] !== '\"') {\r\n                color += line[idx];\r\n                idx++;\r\n            }\r\n\r\n            // Get the nodes ID's\r\n            const numbers = line\r\n                .substring(idx + 1, line.length - 1)\r\n                .split(/\\s/)\r\n                .filter((str) => str.length)\r\n                .map((num) => Number(num));\r\n\r\n            let thisType: ClusterKind;\r\n            switch (label) {\r\n                case 'SAT':\r\n                    thisType = ClusterKind.SAT;\r\n                    break;\r\n                case 'CNF':\r\n                    thisType = ClusterKind.CNF;\r\n                    break;\r\n                case 'TL':\r\n                    thisType = ClusterKind.TL;\r\n                    break;\r\n                case 'PP':\r\n                    thisType = ClusterKind.PP;\r\n                    break;\r\n                case 'IN':\r\n                    thisType = ClusterKind.IN;\r\n                    break;\r\n                default:\r\n                    thisType = ClusterKind.NONE;\r\n            }\r\n\r\n            // Assign the type for each node\r\n            numbers.forEach((num) => {\r\n                nodes[num].clusterType = thisType;\r\n            });\r\n            clustersInfos[thisType] = color;\r\n        } else if (line.search('label') !== -1) {\r\n            const id = parseInt(line.slice(0, line.indexOf('[')).trim());\r\n            const attributes = line.slice(line.indexOf('[') + 1, line.lastIndexOf(']')).trim();\r\n\r\n            let label = attributes.slice(attributes.search(/(?<!\\\\)\"/) + 2);\r\n            label = label.slice(0, label.search(/(?<!\\\\)\"/) - 1);\r\n            let [conclusion, rule, args] = ['', '', ''];\r\n            [conclusion, rule] = label.split(/(?<!\\\\)\\|/);\r\n            [rule, args] = rule.indexOf(' :args ') != -1 ? rule.split(' :args ') : [rule, ''];\r\n\r\n            const comment: string = removeEscapedCharacters(line.slice(line.indexOf('comment'), line.lastIndexOf('\"')));\r\n            const commentJSON = JSON.parse(comment.slice(comment.indexOf('\"') + 1).replace(/'/g, '\"'));\r\n\r\n            if (!nodes[id]) {\r\n                nodes[id] = {\r\n                    id: id,\r\n                    conclusion: '',\r\n                    rule: '',\r\n                    args: '',\r\n                    children: [],\r\n                    parents: [NaN],\r\n                    descendants: 0,\r\n                    dependencies: [],\r\n                    clusterType: ClusterKind.NONE,\r\n                };\r\n            }\r\n            nodes[id].conclusion = removeEscapedCharacters(conclusion);\r\n            nodes[id].rule = removeEscapedCharacters(rule);\r\n            nodes[id].args = removeEscapedCharacters(args);\r\n            nodes[id].descendants = commentJSON.subProofQty;\r\n        } else if (line.search('->') !== -1) {\r\n            const [child, parent] = line.split('->').map((x) => parseInt(x.trim()));\r\n            nodes[parent].children.push(child);\r\n            // If there isn't a child node\r\n            if (!nodes[child]) {\r\n                nodes[child] = {\r\n                    id: child,\r\n                    conclusion: '',\r\n                    rule: '',\r\n                    args: '',\r\n                    children: [],\r\n                    parents: [],\r\n                    descendants: 0,\r\n                    dependencies: [],\r\n                    clusterType: ClusterKind.NONE,\r\n                };\r\n            }\r\n            // If there is and is an invalid parent\r\n            else if (isNaN(nodes[child].parents[0])) {\r\n                nodes[child].parents = [];\r\n            }\r\n            nodes[child].parents.push(parent);\r\n        }\r\n    });\r\n\r\n    return comment ? [nodes, JSON.parse(comment)['letMap'], clustersInfos] : [nodes, {}, clustersInfos];\r\n}\r\n\r\nexport const piNodeParents = (\r\n    proof: NodeInterface[],\r\n    hiddenNodesArray: number[],\r\n    dependencies: { [parentId: number]: number[] } = {},\r\n): number[] => {\r\n    const parents = hiddenNodesArray\r\n        // Concat all the parents\r\n        .reduce((acc: number[], hiddenNode) => {\r\n            let haveHiddenParent = false;\r\n\r\n            proof[hiddenNode].parents.forEach((parent) => {\r\n                // If this parent is a hidden node\r\n                if (hiddenNodesArray.indexOf(parent) !== -1) {\r\n                    haveHiddenParent = true;\r\n                } else {\r\n                    dependencies[parent]\r\n                        ? dependencies[parent].push(hiddenNode)\r\n                        : (dependencies[parent] = [hiddenNode]);\r\n                }\r\n            });\r\n\r\n            if (haveHiddenParent) return acc;\r\n            return acc.concat(proof[hiddenNode].parents);\r\n        }, [])\r\n        // Filter the duplicated elements\r\n        .filter((parent, i, self) => self.indexOf(parent) === i)\r\n        // Only the parents that aren't in he hidden nodes array remains\r\n        .filter((parent) => hiddenNodesArray.indexOf(parent) === -1);\r\n\r\n    // Removes the pi node parents from the dependencies\r\n    Object.keys(dependencies).forEach((parent) => {\r\n        const n = Number(parent);\r\n        if (parents.indexOf(n) !== -1) delete dependencies[n];\r\n    });\r\n\r\n    return parents;\r\n};\r\n\r\nexport const descendants = (proof: NodeInterface[], nodeId: number): number[] => {\r\n    return proof[nodeId].children.concat(\r\n        proof[nodeId].children.reduce((acc: number[], childId) => acc.concat(descendants(proof, childId)), []),\r\n    );\r\n};\r\n\r\nexport const piNodeChildren = (proof: NodeInterface[], hiddenNodesArray: number[]): number[] => {\r\n    const children = hiddenNodesArray\r\n        // Get all the childrens\r\n        .reduce((acc: number[], hiddenNode) => acc.concat(proof[hiddenNode].children), [])\r\n        // Exclude the childrens that are part of the hidden nodes\r\n        .filter((child) => hiddenNodesArray.indexOf(child) === -1);\r\n    return children;\r\n};\r\n\r\nexport const findNodesClusters = (proof: NodeInterface[], hiddenNodesArray: number[]): number[][] => {\r\n    const hiddenNodes = [...hiddenNodesArray];\r\n    const clusters: number[][] = [];\r\n    let clusteredNodes = 0;\r\n    const parents = hiddenNodes.map((hiddenNode) => proof[hiddenNode].parents);\r\n\r\n    // Cluster the nodes based on similiar parents\r\n    parents.forEach((parent, clusterID) => {\r\n        // If not all of the nodes where clustered and is a non empty cluster\r\n        if (clusteredNodes !== parents.length && parents[clusterID].length) {\r\n            clusters.push([]);\r\n            parents.forEach((p, hiddenID) => {\r\n                // If those nodes have some parent in commom and they weren't verified yet\r\n                if (parents[hiddenID].length && parent.some((_p) => p.indexOf(_p) !== -1)) {\r\n                    clusters[clusters.length - 1].push(hiddenNodes[hiddenID]);\r\n                    // Removes these parents from the array, making shure they will not get verified again (already clustered)\r\n                    parents[hiddenID] = [];\r\n                    // Increases the number o clustered nodes\r\n                    clusteredNodes++;\r\n                }\r\n            });\r\n        }\r\n    });\r\n\r\n    let pastCluster: number[][] = [];\r\n    // Cluster the nodes until there aren't changes being made\r\n    while (JSON.stringify(pastCluster) != JSON.stringify(clusters)) {\r\n        pastCluster = [...clusters];\r\n        clusters.forEach((cluster, clusterID) => {\r\n            const clusterParents = proof[cluster[0]].parents;\r\n\r\n            // For each cluster\r\n            clusters.forEach((parentCluster, id) => {\r\n                // If this parentCluster (cluster) is parent of the current cluster\r\n                if (parentCluster.some((hiddenID) => clusterParents.indexOf(hiddenID) !== -1)) {\r\n                    // Group the nodes couple in one single cluster (the parent cluster)\r\n                    clusters[id] = clusters[id].concat(clusters[clusterID]);\r\n                    clusters.splice(clusterID, 1);\r\n                    clusterID--;\r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n    // Filter the nodes with length 1\r\n    return clusters.filter((cluster) => cluster.length > 1);\r\n};\r\n\r\nexport const groupPiNodeDependencies = (\r\n    proof: NodeInterface[],\r\n    hiddenNodesArray: number[],\r\n): NodeInterface['dependencies'] => {\r\n    const piNodeDependencies: NodeInterface['dependencies'] = [];\r\n    const depMap: { [piID: number]: number } = {};\r\n\r\n    // Copy all the hidden nodes dependencies to the new pi node\r\n    proof.forEach((node) => {\r\n        // Search for all the hidden nodes that have deps\r\n        if (hiddenNodesArray.indexOf(node.id) !== -1 && node.dependencies.length) {\r\n            // For each dependence in this node\r\n            node.dependencies.forEach((dep) => {\r\n                // This pi node dependence wasn't inserted yet\r\n                if (Object.keys(depMap).indexOf(String(dep.piId)) === -1) {\r\n                    piNodeDependencies.push(dep);\r\n                    depMap[dep.piId] = piNodeDependencies.length - 1;\r\n                }\r\n                // Concat the nodes inside the pi node already inserted\r\n                else {\r\n                    piNodeDependencies[depMap[dep.piId]].depsId = piNodeDependencies[depMap[dep.piId]].depsId.concat(\r\n                        dep.depsId,\r\n                    );\r\n                }\r\n            });\r\n        }\r\n    });\r\n    return piNodeDependencies;\r\n};\r\n\r\nexport const sliceNodesCluster = (\r\n    proof: NodeInterface[],\r\n    clusterMap: number[],\r\n    nodeId = 0,\r\n    slicedClusters: number[][] = [],\r\n): number[][] => {\r\n    const currentNode = proof[nodeId];\r\n\r\n    // If the node id is valid and wasn't inserted yet\r\n    if (nodeId && clusterMap[currentNode.id] === -1) {\r\n        // Get all parents with the same type\r\n        const parentsClusters: { [parentID: number]: number } = {};\r\n        for (let i = 0; i < currentNode.parents.length; i++) {\r\n            const p = currentNode.parents[i];\r\n            if (proof[p].clusterType === currentNode.clusterType) {\r\n                parentsClusters[p] = clusterMap[p];\r\n                break;\r\n            }\r\n        }\r\n\r\n        const keys = Object.keys(parentsClusters);\r\n\r\n        // If the current node has the same type as (at least) one of it's parents\r\n        if (keys.length) {\r\n            // Put the current node in the cluster of the first parent with the same type\r\n            const target = parentsClusters[Number(keys[0])];\r\n            slicedClusters[target].push(currentNode.id);\r\n            clusterMap[currentNode.id] = target;\r\n        }\r\n        // Parent with different type\r\n        else {\r\n            const clusterID = slicedClusters.length;\r\n            clusterMap[currentNode.id] = clusterID;\r\n            slicedClusters.push([currentNode.id]);\r\n\r\n            // Add the brothers with the same type in the same cluster\r\n            proof[currentNode.parents[0]].children.forEach((c) => {\r\n                // If the brother node has the same type as the current one\r\n                if (proof[c].clusterType === currentNode.clusterType && c !== currentNode.id) {\r\n                    slicedClusters[clusterID].push(c);\r\n                    clusterMap[c] = clusterID;\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    currentNode.children.forEach((child) => {\r\n        sliceNodesCluster(proof, clusterMap, child, slicedClusters);\r\n    });\r\n    return slicedClusters;\r\n};\r\n\r\nexport const extractTheoryLemmas = (\r\n    proof: NodeInterface[],\r\n    clusters: ProofState['clustersInfos'],\r\n    haveCluster: boolean,\r\n): ProofState['theoryLemmaMap'] => {\r\n    // If have clusters registered\r\n    if (haveCluster) {\r\n        return [proof[0].conclusion].concat(\r\n            clusters.filter((c) => c.type === ClusterKind.TL).map((c) => proof[c.hiddenNodes[0]].conclusion),\r\n        );\r\n    } else {\r\n        return proof.filter((n) => n.rule === 'SCOPE').map((n) => n.conclusion);\r\n    }\r\n};\r\n","export const colorConverter = (colorName: string): string => {\r\n    let color = '#fff';\r\n    switch (colorName) {\r\n        case 'red':\r\n            color = '#f72b34';\r\n            break;\r\n        case 'orange':\r\n            color = '#ff8334';\r\n            break;\r\n        case 'yellow':\r\n            color = '#ffc149';\r\n            break;\r\n        case 'green':\r\n            color = '#60aa51';\r\n            break;\r\n        case 'blue':\r\n            color = '#0097e4';\r\n            break;\r\n        case 'purple':\r\n            color = '#a73da5';\r\n            break;\r\n        case 'brown':\r\n            color = '#a95a49';\r\n            break;\r\n        case 'black':\r\n            color = '#464646';\r\n            break;\r\n\r\n        case 'white':\r\n            color = '#f0f0f0';\r\n            break;\r\n    }\r\n    return color;\r\n};\r\n","import { createSlice, PayloadAction } from '@reduxjs/toolkit';\r\nimport { RootState } from '../../store';\r\nimport {\r\n    processDot,\r\n    piNodeChildren,\r\n    piNodeParents,\r\n    descendants,\r\n    findNodesClusters,\r\n    groupPiNodeDependencies,\r\n    sliceNodesCluster,\r\n    extractTheoryLemmas,\r\n} from './auxi';\r\nimport { NodeInterface, ProofState } from '../../../interfaces/interfaces';\r\nimport { colorConverter } from '../theme/auxi';\r\nimport { ClusterKind } from '../../../interfaces/enum';\r\n\r\nconst initialState: ProofState = {\r\n    proof: [],\r\n    view: 'full',\r\n    style: 'graph',\r\n    hiddenNodes: [],\r\n    letMap: {},\r\n    theoryLemmaMap: [],\r\n    visualInfo: [],\r\n    clustersInfos: [],\r\n    smt: '',\r\n};\r\n\r\nexport const proofSlice = createSlice({\r\n    name: 'proof',\r\n    initialState,\r\n\r\n    reducers: {\r\n        process: (state, action: PayloadAction<string>) => {\r\n            // Reset the state\r\n            state.clustersInfos = [];\r\n\r\n            let proofJSON;\r\n            let dot = action.payload;\r\n            let isJSON = false;\r\n\r\n            // If the payload is a .json file\r\n            if (dot.indexOf('{\"dot\":\"') !== -1) {\r\n                proofJSON = JSON.parse(dot);\r\n                dot = proofJSON.dot;\r\n                isJSON = true;\r\n            }\r\n\r\n            const [proof, letMap, clustersColors] = processDot(dot);\r\n            state.proof = proof;\r\n            state.letMap = letMap;\r\n            state.view = 'full';\r\n\r\n            // If there are clusters\r\n            let clusters: number[][] = [];\r\n            if (Object.keys(clustersColors).length) {\r\n                state.view = 'clustered';\r\n\r\n                // Slice the clusters\r\n                const clustersMap: number[] = Array(state.proof.length).fill(-1);\r\n                clusters = sliceNodesCluster(state.proof, clustersMap);\r\n\r\n                // Maps the cluster infos\r\n                clusters.forEach((cluster) => {\r\n                    const type = state.proof[cluster[0]].clusterType;\r\n                    state.clustersInfos.push({\r\n                        hiddenNodes: cluster,\r\n                        type: type,\r\n                        color: colorConverter(clustersColors[type]),\r\n                    });\r\n                });\r\n\r\n                // Extract the theory lemmas\r\n                state.theoryLemmaMap = extractTheoryLemmas(state.proof, state.clustersInfos, true);\r\n            } else {\r\n                state.theoryLemmaMap = extractTheoryLemmas(state.proof, state.clustersInfos, false);\r\n            }\r\n\r\n            if (isJSON) {\r\n                state.view = proofJSON.view;\r\n                state.hiddenNodes = proofJSON.hiddenNodes;\r\n                state.visualInfo = proofJSON.visualInfo;\r\n            }\r\n            // Is .dot\r\n            else {\r\n                state.hiddenNodes = clusters.filter((c) => c.length > 1);\r\n\r\n                // Init the visual info\r\n                const visualInfo: ProofState['visualInfo'] = {};\r\n                state.proof.forEach((node) => {\r\n                    visualInfo[node.id] = {\r\n                        color: '#fff',\r\n                        x: 0,\r\n                        y: 0,\r\n                        selected: false,\r\n                    };\r\n                });\r\n\r\n                let size = state.proof.length;\r\n                state.clustersInfos.forEach((cluster) => {\r\n                    visualInfo[cluster.hiddenNodes.length !== 1 ? size++ : cluster.hiddenNodes[0]] = {\r\n                        color: cluster.color,\r\n                        x: 0,\r\n                        y: 0,\r\n                        selected: false,\r\n                    };\r\n                });\r\n\r\n                state.visualInfo = visualInfo;\r\n            }\r\n        },\r\n        hideNodes: (state, action: PayloadAction<number[]>) => {\r\n            const toHideNodes = action.payload.filter(\r\n                (id) =>\r\n                    id > 0 &&\r\n                    id < state.proof.length &&\r\n                    state.hiddenNodes.every((hiddenNodesArray) => hiddenNodesArray.indexOf(id) === -1),\r\n            );\r\n\r\n            const clusters = findNodesClusters(state.proof, toHideNodes);\r\n            state.hiddenNodes = state.hiddenNodes\r\n                .concat(clusters)\r\n                .filter((hiddenNodesArray) => hiddenNodesArray.length > 0);\r\n\r\n            // Set the visual info for the new pi nodes\r\n            const piNodeId = Object.keys(state.visualInfo).length;\r\n            for (let i = 0; i < clusters.length; i++) {\r\n                state.visualInfo = {\r\n                    ...state.visualInfo,\r\n                    [piNodeId + i]: {\r\n                        color: '#555',\r\n                        x: 0,\r\n                        y: 0,\r\n                        selected: false,\r\n                    },\r\n                };\r\n            }\r\n\r\n            // Unselect the selected nodes\r\n            toHideNodes.forEach(\r\n                (id) =>\r\n                    (state.visualInfo[id] = {\r\n                        ...state.visualInfo[id],\r\n                        selected: false,\r\n                    }),\r\n            );\r\n        },\r\n        foldAllDescendants: (state, action: PayloadAction<number>) => {\r\n            state.hiddenNodes = state.hiddenNodes\r\n                .concat([\r\n                    [action.payload, ...descendants(state.proof, action.payload)].filter(\r\n                        (id, index, self) =>\r\n                            id > 0 &&\r\n                            id < state.proof.length &&\r\n                            state.hiddenNodes.every((hiddenNodesArray) => hiddenNodesArray.indexOf(id) === -1) &&\r\n                            self.indexOf(id) === index,\r\n                    ),\r\n                ])\r\n                .filter((hiddenNodesArray) => hiddenNodesArray.length > 0);\r\n\r\n            // Set the visual info for the new pi node and the root node\r\n            const piNodeId = Object.keys(state.visualInfo).length;\r\n            state.visualInfo = {\r\n                ...state.visualInfo,\r\n                [action.payload]: {\r\n                    ...state.visualInfo[action.payload],\r\n                    selected: false,\r\n                },\r\n                [piNodeId]: {\r\n                    color: '#555',\r\n                    x: 0,\r\n                    y: 0,\r\n                    selected: false,\r\n                },\r\n            };\r\n        },\r\n        unhideNodes: (state, action: PayloadAction<{ pi: number; hiddens: number[] }>) => {\r\n            const { pi, hiddens } = action.payload;\r\n            state.hiddenNodes = state.hiddenNodes\r\n                .map((hiddenNodesArray) => hiddenNodesArray.filter((id) => hiddens.indexOf(id) === -1))\r\n                .filter((hiddenNodesArray) => hiddenNodesArray.length > 0);\r\n\r\n            // Make sure the ids are realocated\r\n            const size = Object.keys(state.visualInfo).length;\r\n            for (let i = pi; i < size - 1; i++) {\r\n                state.visualInfo[i] = state.visualInfo[i + 1];\r\n            }\r\n            // Delete the last position\r\n            delete state.visualInfo[size - 1];\r\n\r\n            // Unselect the hidden nodes\r\n            hiddens.forEach(\r\n                (id) =>\r\n                    (state.visualInfo[id] = {\r\n                        ...state.visualInfo[id],\r\n                        selected: false,\r\n                    }),\r\n            );\r\n        },\r\n        setVisualInfo: (state, action: PayloadAction<ProofState['visualInfo']>) => {\r\n            state.visualInfo = action.payload;\r\n        },\r\n        selectNodes: (state, action: PayloadAction<number[]>) => {\r\n            const len = Object.keys(state.visualInfo).length;\r\n            action.payload.forEach((id) => {\r\n                if (id >= 0 && id < len) {\r\n                    state.visualInfo[id].selected = true;\r\n                }\r\n            });\r\n        },\r\n        unselectNodes: (state, action: PayloadAction<number[]>) => {\r\n            const len = Object.keys(state.visualInfo).length;\r\n            action.payload.forEach((id) => {\r\n                if (id >= 0 && id < len) {\r\n                    state.visualInfo[id].selected = false;\r\n                }\r\n            });\r\n        },\r\n        changeStyle: (state, action: PayloadAction<ProofState['style']>) => {\r\n            switch (action.payload) {\r\n                case 'graph':\r\n                    state.style = 'graph';\r\n                    break;\r\n                case 'directory':\r\n                    state.style = 'directory';\r\n                    break;\r\n            }\r\n        },\r\n        applyView: (state, action: PayloadAction<ProofState['view']>) => {\r\n            const visualInfoSize = Object.keys(state.visualInfo).length;\r\n            const proofSize = state.proof.length;\r\n            // Delete all the pi nodes\r\n            for (let i = 0; i < visualInfoSize - proofSize; i++) {\r\n                delete state.visualInfo[proofSize + i];\r\n            }\r\n\r\n            switch (action.payload) {\r\n                // View without hidden Nodes\r\n                case 'full':\r\n                    if (state.hiddenNodes.length || state.view === 'colored-full') {\r\n                        state.proof.forEach((node) => {\r\n                            state.visualInfo[node.id] = {\r\n                                color: '#fff',\r\n                                x: 0,\r\n                                y: 0,\r\n                                selected: false,\r\n                            };\r\n                        });\r\n\r\n                        state.hiddenNodes = [];\r\n                    }\r\n                    state.view = 'full';\r\n                    break;\r\n                // Cluster all the nodes in your respective group\r\n                case 'clustered':\r\n                    // If there are clusters infos\r\n                    if (state.clustersInfos.length) {\r\n                        state.view = 'clustered';\r\n\r\n                        state.hiddenNodes = [];\r\n                        let size = Object.keys(state.visualInfo).length;\r\n\r\n                        state.clustersInfos.forEach((cluster) => {\r\n                            if (cluster.hiddenNodes.length !== 1) {\r\n                                state.visualInfo[size++] = {\r\n                                    color: cluster.color,\r\n                                    x: 0,\r\n                                    y: 0,\r\n                                    selected: false,\r\n                                };\r\n\r\n                                state.hiddenNodes.push(cluster.hiddenNodes);\r\n                            }\r\n                            // Cluster with 1 node\r\n                            else {\r\n                                state.visualInfo[cluster.hiddenNodes[0]] = {\r\n                                    color: cluster.color,\r\n                                    x: 0,\r\n                                    y: 0,\r\n                                    selected: false,\r\n                                };\r\n                            }\r\n                        });\r\n                    }\r\n                    break;\r\n                // Apply full view but apply the clustrer color\r\n                case 'colored-full':\r\n                    state.view = 'colored-full';\r\n                    state.hiddenNodes = [];\r\n\r\n                    // If there are clusters infos\r\n                    if (state.clustersInfos.length) {\r\n                        state.clustersInfos.forEach((cluster) => {\r\n                            cluster.hiddenNodes.forEach((node) => {\r\n                                state.visualInfo[node] = {\r\n                                    color: cluster.color,\r\n                                    x: 0,\r\n                                    y: 0,\r\n                                    selected: false,\r\n                                };\r\n                            });\r\n                        });\r\n                    }\r\n                    break;\r\n            }\r\n        },\r\n        applyColor: (state, action: PayloadAction<string>) => {\r\n            Object.keys(state.visualInfo).forEach((id) => {\r\n                if (state.visualInfo[Number(id)].selected) {\r\n                    state.visualInfo[Number(id)].color = action.payload;\r\n                    state.visualInfo[Number(id)].selected = false;\r\n                }\r\n            });\r\n        },\r\n        setSmt: (state, action: PayloadAction<string>) => {\r\n            state.smt = action.payload;\r\n        },\r\n    },\r\n});\r\n\r\nexport const {\r\n    process,\r\n    hideNodes,\r\n    foldAllDescendants,\r\n    unhideNodes,\r\n    setVisualInfo,\r\n    selectNodes,\r\n    unselectNodes,\r\n    changeStyle,\r\n    applyView,\r\n    applyColor,\r\n    setSmt,\r\n} = proofSlice.actions;\r\n\r\nexport const selectProof = (state: RootState): NodeInterface[] => {\r\n    let proof = state.proof.proof;\r\n    const hiddenNodes = state.proof.hiddenNodes;\r\n\r\n    hiddenNodes.forEach((hiddenNodesArray) => {\r\n        const dependencies: { [parentId: number]: number[] } = {};\r\n        const children = piNodeChildren(proof, hiddenNodesArray);\r\n        const parents = piNodeParents(proof, hiddenNodesArray, dependencies);\r\n        const piNodeDependencies = groupPiNodeDependencies(proof, hiddenNodesArray);\r\n\r\n        const piNodeId = proof.length;\r\n        proof = proof.concat({\r\n            id: piNodeId,\r\n            conclusion: '∴',\r\n            rule: 'π',\r\n            args: '',\r\n            children: children,\r\n            parents: parents,\r\n            hiddenNodes: hiddenNodesArray.map((hiddenNode) => proof[hiddenNode]),\r\n            descendants: 1,\r\n            dependencies: piNodeDependencies,\r\n            clusterType: ClusterKind.NONE,\r\n        });\r\n\r\n        const piNode = proof[piNodeId];\r\n\r\n        children.forEach(\r\n            (childId) =>\r\n                (proof[childId] = {\r\n                    ...proof[childId],\r\n                    parents: proof[childId].parents\r\n                        .concat([piNodeId])\r\n                        .filter((proofNode) => hiddenNodesArray.indexOf(proofNode) === -1),\r\n                }),\r\n        );\r\n        parents.forEach(\r\n            (parentId) =>\r\n                (proof[parentId] = {\r\n                    ...proof[parentId],\r\n                    children: proof[parentId].children\r\n                        .concat([piNodeId])\r\n                        .filter((proofNode) => hiddenNodesArray.indexOf(proofNode) === -1),\r\n                }),\r\n        );\r\n\r\n        // Set the dependencies array of each parent that has deps and remove\r\n        //  the children that are dependencies\r\n        Object.keys(dependencies).forEach((parent) => {\r\n            const parentId = Number(parent);\r\n            proof[parentId] = {\r\n                ...proof[parentId],\r\n                children: proof[parentId].children.filter((c) => dependencies[parentId].indexOf(c) === -1),\r\n                dependencies: [...proof[parentId].dependencies, { piId: piNodeId, depsId: dependencies[parentId] }],\r\n            };\r\n        });\r\n\r\n        // Get the high hierarchy nodes in this pi node\r\n        const highHierarchyNodes = hiddenNodesArray?.filter((node) =>\r\n            proof[node].parents.every((parentId) => piNode.parents.indexOf(parentId) !== -1),\r\n        );\r\n\r\n        // Get the conclusion array\r\n        const conclusion = highHierarchyNodes.map((node) => ' ' + proof[node].conclusion);\r\n        piNode.conclusion = conclusion.length > 1 ? `[${conclusion} ]` : `${conclusion}`;\r\n\r\n        // Get the rule array\r\n        const rule = highHierarchyNodes.map((node) => ' ' + proof[node].rule);\r\n        piNode.rule = rule.length > 1 ? `[${rule} ]` : `${rule} `;\r\n\r\n        // Set the descendants number\r\n        piNode.descendants = piNode.children.reduce(\r\n            (ac: number, childID) => ((ac += proof[childID].descendants), ac),\r\n            1,\r\n        );\r\n    });\r\n\r\n    proof = proof.filter((proofNode) =>\r\n        hiddenNodes.every((hiddenNodesArray) => hiddenNodesArray.indexOf(proofNode.id) === -1),\r\n    );\r\n\r\n    return proof;\r\n};\r\n\r\nexport const selectOriginalProof = (state: RootState): NodeInterface[] => {\r\n    return state.proof.proof;\r\n};\r\n\r\nexport const selectView = (state: RootState): ProofState['view'] => {\r\n    return state.proof.view;\r\n};\r\n\r\nexport const selectStyle = (state: RootState): 'graph' | 'directory' => {\r\n    return state.proof.style;\r\n};\r\n\r\nexport const selectLetMap = (state: RootState): { [Key: string]: string } => {\r\n    return state.proof.letMap;\r\n};\r\n\r\nexport const selectTheoryLemmas = (state: RootState): ProofState['theoryLemmaMap'] => {\r\n    return state.proof.theoryLemmaMap;\r\n};\r\n\r\nexport const selectVisualInfo = (state: RootState): ProofState['visualInfo'] => {\r\n    if (state.proof.proof.length) return state.proof.visualInfo;\r\n    // If there is no proof node\r\n    return { 0: { color: '#555', x: 0, y: 0, selected: false } };\r\n};\r\n\r\nexport const selectHiddenNodes = (state: RootState): number[][] => {\r\n    return state.proof.hiddenNodes;\r\n};\r\n\r\nexport const selectNodeClusters = (state: RootState): ProofState['clustersInfos'] => {\r\n    return state.proof.clustersInfos;\r\n};\r\n\r\nexport const selectSmt = (state: RootState): ProofState['smt'] => {\r\n    return state.proof.smt;\r\n};\r\n\r\nexport default proofSlice.reducer;\r\n","import { configureStore, ThunkAction, Action } from '@reduxjs/toolkit';\r\nimport externalCmdReducer from './features/externalCmd/externalCmd';\r\nimport fileReducer from './features/file/fileSlice';\r\nimport proofReducer from './features/proof/proofSlice';\r\nimport themeReducer from './features/theme/themeSlice';\r\n\r\nexport const store = configureStore({\r\n    reducer: {\r\n        file: fileReducer,\r\n        proof: proofReducer,\r\n        theme: themeReducer,\r\n        externalCmd: externalCmdReducer,\r\n    },\r\n});\r\n\r\nexport type AppDispatch = typeof store.dispatch;\r\nexport type RootState = ReturnType<typeof store.getState>;\r\nexport type AppThunk<ReturnType = void> = ThunkAction<ReturnType, RootState, unknown, Action<string>>;\r\n","import { ReportHandler } from 'web-vitals';\r\n\r\nconst reportWebVitals = (onPerfEntry?: ReportHandler): void => {\r\n    if (onPerfEntry && onPerfEntry instanceof Function) {\r\n        import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\r\n            getCLS(onPerfEntry);\r\n            getFID(onPerfEntry);\r\n            getFCP(onPerfEntry);\r\n            getLCP(onPerfEntry);\r\n            getTTFB(onPerfEntry);\r\n        });\r\n    }\r\n};\r\n\r\nexport default reportWebVitals;\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport App from './components/App/App';\r\nimport { store } from './store/store';\r\nimport { Provider } from 'react-redux';\r\n\r\nimport './scss/index.scss';\r\n\r\nimport reportWebVitals from './ReactUtils/reportWebVitals';\r\n\r\nReactDOM.render(\r\n    <React.StrictMode>\r\n        <Provider store={store}>\r\n            <App />\r\n        </Provider>\r\n    </React.StrictMode>,\r\n    document.getElementById('root'),\r\n);\r\n\r\n// If you want to start measuring performance in your app, pass a function\r\n// to log results (for example: reportWebVitals(console.log))\r\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\r\nreportWebVitals();\r\n"],"sourceRoot":""}